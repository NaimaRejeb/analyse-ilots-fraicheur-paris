{
  "hash": "d9e94193ffc2d3224808ff218fef0c22",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"PrÃ©traitement des DonnÃ©es\"\nsubtitle: \"Nettoyage et prÃ©paration des donnÃ©es brutes\"\nformat:\n  html:\n    theme: cosmo\n    toc: true\n    toc-depth: 3\n    code-fold: true\n---\n\n# ğŸ§¹ Introduction au PrÃ©traitement\n\nLe prÃ©traitement est une Ã©tape **cruciale** dans tout projet d'analyse de donnÃ©es. Cette page documente les diffÃ©rentes transformations appliquÃ©es aux donnÃ©es brutes des Ã®lots de fraÃ®cheur.\n\n::: {.callout-important}\n## Pourquoi prÃ©traiter ?\n\n- Ã‰liminer les **doublons** et donnÃ©es invalides\n- Standardiser les **formats** des variables\n- CrÃ©er de **nouvelles variables** utiles pour l'analyse\n- Garantir la **qualitÃ©** des rÃ©sultats\n:::\n\n# ğŸ“¥ DonnÃ©es Brutes\n\n## Chargement initial\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# URL du dataset Open Data Paris\nurl <- \"https://opendata.paris.fr/api/explore/v2.1/catalog/datasets/ilots-de-fraicheur-equipements-activites/exports/csv\"\n\n# Import des donnÃ©es brutes\ndonnees_brutes <- read.csv2(url, encoding = \"UTF-8\", stringsAsFactors = FALSE)\n\ncat(\"ğŸ“Š DONNÃ‰ES BRUTES\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<U+0001F4CA> DONNÃ‰ES BRUTES\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501>\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Lignes:\", nrow(donnees_brutes), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLignes: 548 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Colonnes:\", ncol(donnees_brutes), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nColonnes: 19 \n```\n\n\n:::\n:::\n\n\n## AperÃ§u des colonnes\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Liste des colonnes\ndata.frame(\n  Index = 1:ncol(donnees_brutes),\n  Colonne = names(donnees_brutes),\n  Type = sapply(donnees_brutes, class)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                     Index              Colonne      Type\nX.U.FEFF.identifiant     1 X.U.FEFF.identifiant character\nid_dicom                 2             id_dicom character\nnom                      3                  nom character\ntype                     4                 type character\npayant                   5               payant character\nadresse                  6              adresse character\narrondissement           7       arrondissement   integer\nstatut_ouverture         8     statut_ouverture character\nhoraires_periode         9     horaires_periode character\nhoraires_lundi          10       horaires_lundi character\nhoraires_mardi          11       horaires_mardi character\nhoraires_mercredi       12    horaires_mercredi character\nhoraires_jeudi          13       horaires_jeudi character\nhoraires_vendredi       14    horaires_vendredi character\nhoraires_samedi         15      horaires_samedi character\nhoraires_dimanche       16    horaires_dimanche character\ngeo_shape               17            geo_shape character\ngeo_point_2d            18         geo_point_2d character\nproposition_usager      19   proposition_usager character\n```\n\n\n:::\n:::\n\n\n# ğŸ” Analyse des Valeurs Manquantes\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Analyser les valeurs manquantes\nanalyse_na <- data.frame(\n  Colonne = names(donnees_brutes),\n  NA_count = sapply(donnees_brutes, function(x) sum(is.na(x))),\n  Vide_count = sapply(donnees_brutes, function(x) sum(x == \"\", na.rm = TRUE))\n)\nanalyse_na$Pourcentage <- round((analyse_na$NA_count + analyse_na$Vide_count) / nrow(donnees_brutes) * 100, 1)\nanalyse_na <- analyse_na[order(-analyse_na$Pourcentage), ]\n\n# Afficher les colonnes avec donnÃ©es manquantes\nprint(analyse_na[analyse_na$Pourcentage > 0, ], row.names = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            Colonne NA_count Vide_count Pourcentage\n   statut_ouverture        0        517        94.3\n     horaires_lundi        0        425        77.6\n     horaires_mardi        0        425        77.6\n  horaires_mercredi        0        425        77.6\n     horaires_jeudi        0        425        77.6\n  horaires_vendredi        0        425        77.6\n  horaires_dimanche        0        425        77.6\n    horaires_samedi        0        424        77.4\n           id_dicom        0        303        55.3\n   horaires_periode        0        109        19.9\n             payant        0         17         3.1\n proposition_usager        0          7         1.3\n            adresse        0          2         0.4\n               type        0          1         0.2\n```\n\n\n:::\n:::\n\n\n::: {.callout-note}\n## Observations\n\n- **statut_ouverture** : 94% de valeurs manquantes â†’ peu exploitable\n- **horaires_*** : ~77% manquantes â†’ information partielle\n- **type** et **payant** : trÃ¨s peu de donnÃ©es manquantes â†’ exploitables\n:::\n\n# ğŸ§¼ Ã‰tapes de Nettoyage\n\n## 1. Nettoyage des chaÃ®nes de caractÃ¨res\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndonnees <- donnees_brutes\n\n# Fonction de nettoyage\nnettoyer_texte <- function(x) {\n  if (!is.character(x)) return(x)\n  x <- trimws(x)                    # Supprimer espaces dÃ©but/fin\n  x <- gsub(\"\\\\s+\", \" \", x)         # Remplacer espaces multiples\n  x[x == \"\"] <- NA                  # Convertir vides en NA\n  return(x)\n}\n\n# Appliquer aux colonnes texte\ncolonnes_texte <- c(\"nom\", \"type\", \"adresse\", \"arrondissement\", \"payant\")\nfor (col in colonnes_texte) {\n  if (col %in% names(donnees)) {\n    donnees[[col]] <- nettoyer_texte(donnees[[col]])\n  }\n}\n\ncat(\"âœ… ChaÃ®nes de caractÃ¨res nettoyÃ©es\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<U+2705> ChaÃ®nes de caractÃ¨res nettoyÃ©es\n```\n\n\n:::\n:::\n\n\n## 2. Suppression des doublons\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# CrÃ©er une clÃ© unique\ndonnees$cle_unique <- paste(donnees$nom, donnees$adresse, donnees$type, sep = \"|\")\n\n# Compter les doublons\nn_avant <- nrow(donnees)\ndoublons <- duplicated(donnees$cle_unique)\nn_doublons <- sum(doublons)\n\n# Supprimer les doublons\ndonnees <- donnees[!doublons, ]\ndonnees$cle_unique <- NULL\n\ncat(\"ğŸ“‹ SUPPRESSION DES DOUBLONS\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<U+0001F4CB> SUPPRESSION DES DOUBLONS\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501>\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Lignes avant:\", n_avant, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLignes avant: 548 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Doublons dÃ©tectÃ©s:\", n_doublons, \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDoublons dÃ©tectÃ©s: 28 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Lignes aprÃ¨s:\", nrow(donnees), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLignes aprÃ¨s: 520 \n```\n\n\n:::\n:::\n\n\n## 3. Extraction des coordonnÃ©es GPS\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extraire latitude et longitude\nif (\"geo_point_2d\" %in% names(donnees)) {\n  coords <- strsplit(as.character(donnees$geo_point_2d), \",\")\n  donnees$latitude <- as.numeric(sapply(coords, function(x) {\n    if (length(x) >= 1) trimws(x[1]) else NA\n  }))\n  donnees$longitude <- as.numeric(sapply(coords, function(x) {\n    if (length(x) >= 2) trimws(x[2]) else NA\n  }))\n}\n\n# Validation des coordonnÃ©es pour Paris\nlat_min <- 48.80; lat_max <- 48.92\nlon_min <- 2.22; lon_max <- 2.47\n\ncoords_invalides <- which(\n  donnees$latitude < lat_min | donnees$latitude > lat_max |\n  donnees$longitude < lon_min | donnees$longitude > lon_max\n)\n\ncat(\"ğŸŒ COORDONNÃ‰ES GPS\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<U+0001F30D> COORDONNÃ‰ES GPS\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501><U+2501>\n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"Points valides:\", sum(!is.na(donnees$latitude)), \"/\", nrow(donnees), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nPoints valides: 520 / 520 \n```\n\n\n:::\n\n```{.r .cell-code}\ncat(\"CoordonnÃ©es hors Paris:\", length(coords_invalides), \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordonnÃ©es hors Paris: 0 \n```\n\n\n:::\n:::\n\n\n# ğŸ”§ CrÃ©ation de Nouvelles Variables\n\n## Variables catÃ©gorielles\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Normaliser la colonne \"payant\"\ndonnees$payant <- tolower(donnees$payant)\ndonnees$payant <- ifelse(donnees$payant %in% c(\"oui\", \"yes\", \"1\"), \"Oui\",\n                  ifelse(donnees$payant %in% c(\"non\", \"no\", \"0\"), \"Non\", NA))\n\n# Variable binaire\ndonnees$est_payant <- ifelse(donnees$payant == \"Oui\", TRUE, FALSE)\n\n# Extraire le numÃ©ro d'arrondissement\ndonnees$num_arrondissement <- as.integer(gsub(\"750\", \"\", donnees$arrondissement))\n\ncat(\"âœ… Variables normalisÃ©es crÃ©Ã©es\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<U+2705> Variables normalisÃ©es crÃ©Ã©es\n```\n\n\n:::\n:::\n\n\n## Zones gÃ©ographiques\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# CrÃ©er des zones de Paris\ndonnees$zone_paris <- cut(donnees$num_arrondissement,\n                          breaks = c(0, 4, 8, 12, 16, 20),\n                          labels = c(\"Centre (1-4)\", \"Ouest (5-8)\", \n                                    \"Sud (9-12)\", \"Sud-Ouest (13-16)\", \n                                    \"Nord-Est (17-20)\"),\n                          include.lowest = TRUE)\n\ntable(donnees$zone_paris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n     Centre (1-4)       Ouest (5-8)        Sud (9-12) Sud-Ouest (13-16) \n               60                77                95               130 \n Nord-Est (17-20) \n              158 \n```\n\n\n:::\n:::\n\n\n## CatÃ©gorisation des types\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fonction de catÃ©gorisation\ncategoriser_type <- function(type) {\n  categorie <- rep(\"Autre\", length(type))\n  categorie[grepl(\"piscine|baignade|bain\", type, ignore.case = TRUE)] <- \"Aquatique\"\n  categorie[grepl(\"brumisateur|fontaine\", type, ignore.case = TRUE)] <- \"RafraÃ®chissement\"\n  categorie[grepl(\"musÃ©e|bibliothÃ¨que|culte\", type, ignore.case = TRUE)] <- \"BÃ¢timent climatisÃ©\"\n  categorie[grepl(\"ombriÃ¨re|ombre\", type, ignore.case = TRUE)] <- \"Ombrage\"\n  categorie[grepl(\"parc|jardin|square|terrain\", type, ignore.case = TRUE)] <- \"Espace vert\"\n  categorie[grepl(\"mairie|dÃ©couverte\", type, ignore.case = TRUE)] <- \"Service public\"\n  return(categorie)\n}\n\ndonnees$categorie <- categoriser_type(donnees$type)\ntable(donnees$categorie)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n         Aquatique              Autre BÃ¢timent climatisÃ©        Espace vert \n                66                  1                207                 14 \n           Ombrage   RafraÃ®chissement     Service public \n               112                 97                 23 \n```\n\n\n:::\n:::\n\n\n# ğŸ“Š RÃ©sumÃ© du PrÃ©traitement\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresume <- data.frame(\n  MÃ©trique = c(\n    \"Lignes initiales\",\n    \"Lignes aprÃ¨s nettoyage\",\n    \"Doublons supprimÃ©s\",\n    \"Points GPS valides\",\n    \"Types d'Ã©quipements\",\n    \"Arrondissements couverts\",\n    \"Ã‰quipements gratuits\",\n    \"Ã‰quipements payants\"\n  ),\n  Valeur = c(\n    nrow(donnees_brutes),\n    nrow(donnees),\n    n_doublons,\n    sum(!is.na(donnees$latitude)),\n    length(unique(na.omit(donnees$type))),\n    length(unique(na.omit(donnees$arrondissement))),\n    sum(donnees$payant == \"Non\", na.rm = TRUE),\n    sum(donnees$payant == \"Oui\", na.rm = TRUE)\n  )\n)\n\nprint(resume)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                  MÃ©trique Valeur\n1         Lignes initiales    548\n2   Lignes aprÃ¨s nettoyage    520\n3       Doublons supprimÃ©s     28\n4       Points GPS valides    520\n5      Types d'Ã©quipements     12\n6 Arrondissements couverts     20\n7     Ã‰quipements gratuits    414\n8      Ã‰quipements payants     89\n```\n\n\n:::\n:::\n\n\n## Visualisation du rÃ©sumÃ©\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Graphique comparatif avant/aprÃ¨s\npar(mar = c(5, 10, 4, 2))\nbarplot(\n  c(nrow(donnees_brutes), nrow(donnees), n_doublons),\n  names.arg = c(\"DonnÃ©es brutes\", \"AprÃ¨s nettoyage\", \"Doublons supprimÃ©s\"),\n  horiz = TRUE,\n  col = c(\"#3498db\", \"#2ecc71\", \"#e74c3c\"),\n  main = \"Impact du prÃ©traitement sur les donnÃ©es\",\n  xlab = \"Nombre de lignes\",\n  las = 1\n)\n```\n\n::: {.cell-output-display}\n![](pretraitement_files/figure-html/unnamed-chunk-22-1.png){width=768}\n:::\n:::\n\n\n# ğŸ“ Fichiers GÃ©nÃ©rÃ©s\n\nLe script de prÃ©traitement gÃ©nÃ¨re les fichiers suivants :\n\n| Fichier | Description |\n|---------|-------------|\n| `data/donnees_nettoyees.csv` | DonnÃ©es complÃ¨tes aprÃ¨s nettoyage |\n| `outputs/resume_pretraitement.csv` | RÃ©sumÃ© statistique du prÃ©traitement |\n| `outputs/analyse_valeurs_manquantes.csv` | DÃ©tail des valeurs manquantes |\n\n::: {.callout-tip}\n## Utilisation des donnÃ©es nettoyÃ©es\n\nPour les analyses suivantes, utilisez le fichier nettoyÃ© :\n\n```r\ndonnees <- read.csv(\"data/donnees_nettoyees.csv\", encoding = \"UTF-8\")\n```\n:::\n\n---\n\n::: {.callout-important}\n## Points clÃ©s du prÃ©traitement\n\n1. **28 doublons supprimÃ©s** â†’ donnÃ©es plus fiables\n2. **CoordonnÃ©es GPS validÃ©es** â†’ cartographie prÃ©cise  \n3. **Variables enrichies** â†’ analyses plus riches\n4. **DonnÃ©es standardisÃ©es** â†’ cohÃ©rence garantie\n:::\n",
    "supporting": [
      "pretraitement_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}